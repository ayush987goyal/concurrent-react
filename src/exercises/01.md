# Simple Data-fetching

> ðŸ¦‰ Make sure Kent shows you how to enable Concurrent Mode. It's pretty simple,
> so there's no exercise, but don't let him forget to show you! Oh, and he wrote
> a blog post about it too:
> https://kentcdodds.com/blog/how-to-enable-react-concurrent-mode

## Background

We're going to start off as simple as possible, but it's still going to feel a
little different from anything you've probably done with async data loading
before, so buckle up.

First, there's the Suspense API. Here's the basic idea:

```javascript
function Component() {
  if (data) {
    return <div>{data.message}</div>
  }
  throw promise
  // React with catch this, find the closest "Suspense" component
  // and "suspend" everything from there down from rendering until the
  // promise resolves.
  // ðŸš¨ THIS "API" IS LIKELY TO CHANGE
}

ReactDOM.createRoot(rootEl).render(
  <React.Suspense fallback={<div>loading...</div>}>
    <Component />
  </React.Suspense>,
)
```

That's the idea. Where the `data` and `promise` values are coming from all
depends on how you implement things, and that's what we're going to do in this
exercise.

Imagine when your app loads, you need some data before you can show anything
useful. Typically we want to put the data loading requirements right in the
component that requires the data, via something like this:

```javascript
React.useEffect(() => {
  let current = true
  setState({status: 'pending'})
  doAsyncThing().then(
    p => {
      if (current) setState({pokemon: p, status: 'success'})
    },
    e => {
      if (current) setState({error: e, status: 'error'})
    },
  )
  return () => (current = false)
}, [pokemonName])

// render stuff based on the state
```

However, for "bootstrap" type data, we can start that request before we even
render the app. The best approaches to using Suspense involve kicking off the
request for the data as soon as you have the information you need for the
request. This is called the "Render as you fetch" approach. We'll get into that
a little bit more in future exercises, but keep that in mind.

ðŸ“œ Here are some docs for you if you need them:

- [`<React.Suspense />`](https://reactjs.org/docs/concurrent-mode-reference.html#suspense)

### Promises

Through all of this you should have a firm understanding of promises. Here's a
quick example though:

```javascript
const handleSuccess = result => console.log(result)
const handleFailure = error => console.error(error)

const myPromise = someAsyncFunction().then(handleSuccess, handleFailure)
```

## Exercise

In this exercise, we have a page that's specifically for the pokemon named
Pikachu and we want to load Pikachu's data as soon as the app starts. You're
going to use an `ErrorBoundary` that I've built for you (as relevant as they are
to this topic, the concept of `Error Boundaries` long pre-dates Suspense, so we
won't be getting into it for this workshop). You'll also be using the
`React.Suspense` API.

## Extra Credit

### ðŸ’¯ add error handling with an Error Boundary

What happens if you mistype `pikachu` and instead try to request `pikacha`? This
will result in an error and we need to handle this.

In React, the way we handle component errors is with an `ErrorBoundary`.

> ðŸ“œ Read up on
> [Error Boundaries](https://reactjs.org/docs/error-boundaries.html) if you
> haven't used them much before.

We've got an `ErrorBoundary` component all built-out for you and you can import
it from the `utils` file (It's where we're getting the `PokemonDataView`
component right now).

So you'll wrap your component in an ErrorBoundary for handling that error. But
then you need to turn your promise's error into an error the ErrorBoundary can
handle.

For this extra credit, think of the error as similar to the pokemon data. You'll
need a handler to get access to the error object, and then instead of _using_ it
in your JSX, you can simply _throw_ it in your render method:

```javascript
function Example() {
  if (error) {
    throw error
  }
  // ... etc
}
```

Give that a try!

### ðŸ’¯ make more generic createResource

This is also a JavaScript refactor, but in this case we want to make a generic
"resource factory" which has the following API:

```javascript
const resource = createResource(() => someAsyncThing())

function MyComponent() {
  const myData = resource.read()
  // render myData stuff
}
```

Try to refactor your code a bit to have a resource factory we can use for all
our async needs.

### ðŸ’¯ Use utils

There are a bunch of utilities in the `src/utils.js` file that we'll be using a
bunch during this workshop. Refactor your code to use those so you're familiar
with them. Two you can use for this one are: `PokemonInfoFallback` and
`createResource`!
