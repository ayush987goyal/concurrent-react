# Render as you fetch

## Background

This one's a bit of a mind bender, but here's the ultimate goal we're looking
for: https://twitter.com/kentcdodds/status/1191922859762843649

We wont get the whole way there in this exercise, but we'll get a bunch of the
way there. Then in exercise 04 we can finish it up. So fast âš¡

The idea here is that: get the data as soon as you have the information you need
for the data. This sounds obvious, but if you think about it, how often do you
have a component that requests data once it's been mounted. There's a few
milliseconds between the time you click "go" and the time that component is
mounted... Unless that component's code is lazy-loaded. In which case, there's a
lot more time involved and your users are hanging around waiting while they
could be making requests for the data they need.

That's the entire idea behind "Render as you fetch."

The information often involves a user's

## Exercise

In this one, we now have a form that allows us to choose a pokemon by any name.
As soon as the user hits "submit", we pass the `pokemonName` to our
`PokemonInfo` component which makes the request to get the pokemon data (using
`useEffect`).

For the exercise, you need to refactor this from `useEffect` to Suspense. You'll
need to add the `ErrorBoundary` and `Suspense` components to the `PokemonInfo`
component, and you'll pass the pokemon resource to `PokemonInfoView` which will
call `.read()` on the resource. The initial `.read()` call will trigger the
component to suspend and display the fallback state. When the promise resolves,
React will re-render our components and we'll be able to display the pokemon.

> The real important parts of the render-as-you-fetch approach comes in the
> extra credit, but changing things to this will help a lot to get us going.

## Extra Credit

So far, we've benefitted from an API standpoint. I think the Suspense solution
is simpler than the `useEffect` version. However, we've not gotten the "Render
as you fetch" benefit when it comes to asynchronously loading the code we need.

These extra credit allow you to compare the two approaches.

ðŸ¦‰ For both of these, we're calling `window.fetch.restoreOriginalFetch()` at the
top of our file so our fetch requests actually hit the network so we can see
them in the network tab.

### ðŸ’¯ Suspense and Error Boundary positioning

You don't have to wrap the suspending component in a suspense and error boundary
directly. There can be many layers of nesting and it'll still work. But there's
some semantically important differences that I want you to learn about so go
ahead and try to play around with wrapping more of your elements in these
boundaries and see what changes with the user experience.
